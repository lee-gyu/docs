# item.3 암묵적인 형변환에 주의하라

암묵적인 형변환(implicit coercion)은 자바스크립트의 특징이다.\
이는 자바스크립트가 동적 타입 언어이기 때문에 가능한 것이다.\
아래의 식은 대부분의 언어에서 오류로 처리한다.

```js
3 + true
```

true는 불리언 표현식으로 산순 연산에 허용이 되지 않아야 하지만,\
자바스크립트에서는 문제 없이 실행한다.

자바스크립트에서 잘못된 평가로 처리하는 경우는 아래와 같다.

- null이나 undefined의 프로퍼티 접근
- 함수가 아닌데 함수처럼 호출

이외의 연산 식에 대해서는 암묵적인 형변환을 통해 처리한다.\
산술 연산에서는 숫자로 변환하고, 불리언 연산에서는 불리언으로 변환한다.

만약, 숫자와 문자열을 연결한다면 어떻게 되는가?

```js
1 + 2 + "3" // 33
```

곱하기의 경우는 어떻게 될까?

```js
1 * "2" // 2 "2"를 number로 암묵적 변환
```

null은 산술 연산식에서 0으로 변환된다.\
undefined는 NaN으로 변환된다.

게다가 NaN의 경우는 참으로 이상한 방식으로 동작하는 문제가 있다.\
바로 서로 동등 비교(NaN === Nan)를하면 false로 나온다는 말이다.

그래서 아래와 같은 방식으로 isNaN을 구현할 수도 있다.

```js
function isNaN(x) {
  return x !== x;
}
```

즉, NaN은 자바스크립트에서 자기 자신이 동일하지 않는 유일한 값이다.\

내장된 Number.isNaN 함수가 있지만, 이는 ES6에서 추가된 함수이다.\
따라서, ES6 이전의 환경에서는 위와 같은 방식으로 구현하여야 한다.

추가적으로 오브젝트 타입의 경우 `toString`, `valueOf` 메서드를 통해\
문자열과 숫자로 변환할 수 있다.\
이것은 모두 오버로딩할 수 있으며, 구현이 안된 경우 기본 Object의 프로토타입의 메소드를 사용한다.

단, 여기서 toString과 valueOf 모두 정의된 경우에서 + 연산을 하면 어떻게 될까?\
문자열 병합과 덧셈 연산이 데이터형에 따라 결정되는데, 먼저 valueOf를 실행한 후,\
해당 결과에 toString을 실행하여 처리한다.\
다만 이는 toString으로 취급 되어야하는 경우 혼란을 줄 수 있다.

따라서 가능하면 암묵적인 형변환을 활용하는 것은 조심스럽게 다루어야 한다.

강제형 변환의 마지막 종류로는 truthy와 falsy가 있다.\
자바스크립트에서 false로 취급되는 타입은 아래와 같이 7개가 있다.\
이외의 타입은 모두 true로 취급된다.

- false
- undefined
- null
- 0, -0
- NaN
- ''(빈 문자열)

추가로 완벽하게 undefined를 평가하려면 typeof를 사용해야 한다.

동적 언어의 특징으로 이러한 암묵적 형변환은 종종 디버깅을 어렵게 하며,\
오류를 숨긴다. 따라서, 가능한 코딩한 소스 코드에서 일어날 형변환을 미리 생각하고,\
타입을 명확히 하는 것이 좋다.

## 정리

- 자바스크립트는 동적 타입 언어이다.
- 암묵적인 형변환은 자바스크립트의 특징이다.
- 암묵적인 형변환은 디버깅을 어렵게 하며, 오류를 숨긴다.
- `+` 연산자는 데이터형에 따라 덧셈 또는 문자열 병합으로 오버로딩된다.
- 객체는 toString과 valueOf 메서드를 통해 문자열과 숫자로 변환할 수 있다.
- valueOf 메소드를 가지는 객체는 valueOf에 의해 생성되는 숫자 값의 문자열 표현도 고려해야 한다.
- NaN은 자기 자신과 동일하지 않은 유일한 값이다.
- undefined를 정확히 평가해야한다면 typeof가 좋다.
- truthy와 falsy에 대해 알아야 한다.
